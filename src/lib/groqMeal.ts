// src/lib/groqMeal.ts

import Groq from 'groq-sdk';

// --- SDK Type Imports ---
import {
    ChatCompletionCreateParamsNonStreaming,
    ChatCompletionCreateParamsStreaming,
    ChatCompletionCreateParamsBase,
    ChatCompletionMessageParam,
    ChatCompletion
} from 'groq-sdk/resources/chat/completions';

// --- Appwrite Type Imports ---
import { UserProfile } from './appwrite'; // Adjust path if necessary

// --- Constants for Type Validation ---

/** Valid meal types allowed in the MealIdea interface. */
export const VALID_MEAL_TYPES = ["Breakfast", "Lunch", "Dinner", "Snack", "Dessert"] as const;
/** Union type representing allowed meal types. */
export type MealType = typeof VALID_MEAL_TYPES[number];

/** Valid recipe complexity levels. */
export const VALID_RECIPE_COMPLEXITY = ["Easy", "Medium", "Hard"] as const;
/** Union type representing allowed recipe complexities. */
export type RecipeComplexity = typeof VALID_RECIPE_COMPLEXITY[number];

// --- Interface Definitions ---

/**
 * Represents a single meal idea generated by the AI.
 * Includes more detail for popup view.
 */
export interface MealIdea {
  /** Unique identifier (can be generated client-side or by AI if prompted) */
  id: string;
  /** Name of the meal */
  name: string;
  /** Short description, key ingredients, nutritional highlight (Markdown possible) */
  description: string;
  /** Type of meal (e.g., "Breakfast", "Snack") */
  mealType: MealType | string; // Allows string fallback if AI deviates
  /** Array of main ingredients (e.g., ["Chicken Breast", "Broccoli", "Quinoa"]) */
  keyIngredients?: string[];
  /** Applicable dietary flags (e.g., ["Gluten-Free", "Vegetarian"]) */
  dietaryNotes?: string[];
  /** Estimated preparation time (e.g., "Approx. 15 mins") */
  prepTime?: string;
  /** Estimated cooking time (e.g., "Approx. 30 mins") */
  cookingTime?: string;
  /** Difficulty level (e.g., "Easy") */
  recipeComplexity?: RecipeComplexity | string; // Allows string fallback
  /** Estimated serving size (e.g., "Serves 2") */
  servingSize?: string;
  /** Estimated macros as a string, e.g., "P: 30g, C: 45g, F: 15g" */
  macros?: string;
  /** Array of step-by-step instructions */
  preparationSteps?: string[];
  /** AI's explanation for why this suggestion is relevant */
  reasoning?: string;
}

/** Structure for the AI's response, specialized for meals */
export interface PersonalizedMealContent {
  /** Array of generated meal ideas */
  meals: MealIdea[];
}

/** Options to customize the meal generation request */
export interface MealGenerationOptions {
  /** Approximate number of meal suggestions desired. Defaults to 3. */
  count?: number;
  /** A specific user request, craving, or area of focus to guide the AI. */
  customPreference?: string;
}

// --- Internal Types ---
/** Local union type for Groq Chat Completion Create parameters */
type ChatCompletionCreateParams = ChatCompletionCreateParamsNonStreaming | ChatCompletionCreateParamsStreaming;

// --- Configuration ---
/** Groq API Key loaded from environment variables. */
const API_KEY: string | undefined = import.meta.env.VITE_PUBLIC_GROQ_API_KEY;
/** Specifies the Groq AI model to use for generation. */
const MODEL_NAME: ChatCompletionCreateParamsBase['model'] = "llama3-70b-8192";

// Validate API Key presence
if (!API_KEY) {
    // In a production environment, you might throw an Error here
    // to prevent the application module from loading incorrectly.
    // throw new Error("Groq API Key is missing. Cannot initialize groqMealService.");
    console.error("CRITICAL ERROR: VITE_PUBLIC_GROQ_API_KEY is missing. Meal generation will be unavailable.");
}

/** Initialized Groq SDK client instance, or null if API key is missing. */
const groq: Groq | null = API_KEY ? new Groq({ apiKey: API_KEY, dangerouslyAllowBrowser: true }) : null;

/** Configuration settings for the AI generation process. */
const generationConfig = {
    temperature: 0.7,
    max_tokens: 4096, // Sufficient for detailed JSON output
    top_p: 0.9,
};

// --- Helper Functions ---

/**
 * Helper to get basic trimester info based on weeks pregnant.
 * @param weeks - Weeks pregnant (number or string). Can be undefined/null/NaN.
 * @returns A descriptive string about the trimester or status.
 */
const getTrimesterInfo = (weeks: number | string | undefined | null): string => {
    const numWeeks = parseInt(String(weeks), 10); // Attempt to parse whatever is given
    if (isNaN(numWeeks) || numWeeks < 1) return "Pregnancy stage unknown"; // Handle invalid or zero weeks
    if (numWeeks <= 13) return "First trimester";
    if (numWeeks <= 27) return "Second trimester";
    if (numWeeks <= 42) return "Third trimester"; // Allow slightly beyond 40
    return "Post-term or invalid weeks"; // Handle cases beyond typical range
};

/**
 * Creates the detailed prompt for the Groq API based on user profile and options,
 * focused solely on generating meal ideas. Includes context, safety guidelines,
 * role definition, and strict JSON output format instructions.
 *
 * @param profile - The user's profile data from Appwrite.
 * @param options - Options to customize the request (count, custom preference).
 * @returns The formatted prompt string ready for the API call.
 */
const createMealPersonalizationPrompt = (profile: UserProfile, options: MealGenerationOptions = {}): string => {
    // Destructure options with defaults
    const { count = 3, customPreference } = options;

    // Safely extract profile data with fallbacks
    const weeks = profile.weeksPregnant ?? 'unknown';
    const activity = profile.activityLevel ?? 'unspecified';
    const conditions = profile.preExistingConditions?.trim() || 'none specified';
    const diet = profile.dietaryPreferences?.length ? profile.dietaryPreferences.join(', ') : 'none specified';

    // Build context string
    let context = `**User Context:**\n`;
    context += `- Pregnancy Stage: ${weeks} weeks (Implications: ${getTrimesterInfo(weeks)})\n`;
    context += `- Stated Activity Level: ${activity}\n`;
    context += `- Stated Dietary Preferences: ${diet}\n`;
    if (conditions !== 'none specified') {
        context += `- Stated Pre-existing Conditions: ${conditions} (Acknowledge for context only, DO NOT give medical advice related to these)\n`;
    }
    if (customPreference?.trim()) {
        context += `- User's Current Meal Request/Focus: "${customPreference.trim()}"\n`;
    }
    // Add guidance for minimal context
    if (weeks === 'unknown' && activity === 'unspecified' && diet === 'none specified' && conditions === 'none specified') {
        context += `- Note: User profile context is minimal. Provide generally safe and helpful pregnancy meal suggestions.\n`;
    }

    // Define safety instructions and AI role
    const safetyInstructions = `
**Safety & Role Definition:**
- You are MomCare AI, an informational assistant providing general meal suggestions. You are **NOT** a medical professional, doctor, or registered dietitian. Your advice is not a substitute for professional consultation.
- **ALL meal suggestions are purely informational and MUST NOT be taken as medical or professional dietary advice.**
- **CRITICAL (Meal Safety):** For **every** meal suggestion, the "description" or "reasoning" **MUST** clearly state that it's a general idea and individual dietary needs vary significantly during pregnancy. Advise the user to consult their healthcare provider or a registered dietitian for personalized dietary plans. Macros provided are **estimates only**. Preparation steps are **suggestions**.
- Base suggestions on general, evidence-based knowledge about pregnancy nutritional needs (e.g., importance of folate, iron, calcium, protein).
- Consider common pregnancy food safety guidelines (e.g., avoiding raw/undercooked meats, certain fish, unpasteurized dairy).
- **DO NOT** suggest specific supplement dosages or brands. Always refer the user to their healthcare provider for supplement advice.
- **DO NOT** attempt to diagnose, treat, or manage any medical conditions mentioned in the profile. Acknowledge conditions only to tailor general suggestions appropriately (e.g., suggest recipes aligning with stated dietary needs like 'vegetarian' or 'low-sodium' if mentioned, but without claiming therapeutic effect).
`;

    // Define strict JSON output format for meals only
    const outputFormatInstructions = `
**Output Format Instructions:**
Provide the response STRICTLY as a valid JSON object. NO extra text, greetings, or explanations outside the JSON structure.
The top-level JSON object MUST ONLY have a single key: "meals". The value of "meals" MUST be an array of Meal Idea objects.

Generate approximately ${count} valid meal suggestions relevant to the provided user context and custom request (if any).

**Meal Idea Object Structure (within "meals" array):**
- "id": (string) A unique identifier (you can generate one like "meal-1", "meal-2").
- "name": (string) Catchy and descriptive name.
- "description": (string) 1-3 sentences for card view (benefits, features). Use Markdown. **Must include the disclaimer about consulting a professional.**
- "mealType": (string) Must be one of: ${VALID_MEAL_TYPES.join(', ')}.
- "keyIngredients": (array of strings) List 3-5 main ingredients.
- "dietaryNotes": (array of strings, optional) e.g., ["Vegetarian", "Gluten-Free"]. Empty array [] if none apply.
- "prepTime": (string, optional) e.g., "Approx. 15 mins".
- "cookingTime": (string, optional) e.g., "Approx. 30 mins".
- "recipeComplexity": (string) Must be one of: ${VALID_RECIPE_COMPLEXITY.join(', ')}.
- "servingSize": (string, optional) e.g., "Serves 2-3".
- "macros": (string, optional) Estimated macros, e.g., "Approx. P: 30g, C: 50g, F: 18g per serving". **Must state these are estimates.**
- "preparationSteps": (array of strings) Clear, step-by-step instructions. **Must be an array of strings.**
- "reasoning": (string, optional) Max 20 words on relevance (e.g., "Good source of iron and folate").

**Example Meal Object:**
{
  "id": "meal-1",
  "name": "Lentil Soup with Spinach and Lemon",
  "description": "A hearty and warming soup packed with plant-based iron from lentils and vitamin C from lemon to aid absorption. *Remember, dietary needs vary during pregnancy; consult your healthcare provider or dietitian for personalized advice.*",
  "mealType": "Lunch",
  "keyIngredients": ["Brown Lentils", "Spinach", "Carrots", "Celery", "Lemon"],
  "dietaryNotes": ["Vegetarian", "Gluten-Free", "High-Fiber"],
  "prepTime": "Approx. 15 mins",
  "cookingTime": "Approx. 40 mins",
  "recipeComplexity": "Easy",
  "servingSize": "Serves 4",
  "macros": "Estimated per serving: P: 15g, C: 45g, F: 5g (Values are approximate)",
  "preparationSteps": [
    "Rinse lentils thoroughly.",
    "SautÃ© chopped onions, carrots, and celery in a large pot with olive oil until softened.",
    "Add lentils, vegetable broth, and herbs (like thyme or bay leaf). Bring to a boil, then simmer for 30-35 minutes until lentils are tender.",
    "Stir in fresh spinach until wilted.",
    "Remove from heat. Stir in fresh lemon juice.",
    "Season with salt and pepper to taste. Serve hot."
  ],
  "reasoning": "Excellent source of plant-based iron and folate."
}

**CRITICAL Rules:**
- **Output ONLY the JSON object string.** No introductory text, concluding remarks, or markdown formatting outside the JSON string values.
- Adhere STRICTLY to the requested JSON structure with only the "meals" key containing an array of Meal Idea objects.
- Ensure valid JSON syntax: double quotes for all keys and string values, correct comma placement, valid arrays.
- Ensure all mandatory fields within each meal object are present and non-empty. 'preparationSteps' must be an array of strings.
`;

    // Assemble the final prompt
    return `
You are MomCare AI, an informational assistant for pregnant users. Provide supportive, safe, general meal suggestions based on the user's profile while strictly adhering to safety guidelines and the required JSON output format.

${context}
${safetyInstructions}
Generate personalized meal ideas based *specifically* on the user's context. Ensure all fields in the Meal Idea Object Structure are included. Adhere precisely to the output format instructions below.
${outputFormatInstructions}
`;
};


/**
 * Parses and validates the AI's JSON response for meal ideas.
 * Filters out invalid meal items within the array but preserves valid ones.
 *
 * @param responseText - Raw API response text.
 * @returns Validated PersonalizedMealContent object.
 * @throws Error if JSON is invalid or missing the required top-level "meals" key.
 */
const parseAndValidateMealContent = (responseText: string): PersonalizedMealContent => {
    let cleanedJsonString = responseText.trim();
    const jsonStartIndex = cleanedJsonString.indexOf('{');
    const jsonEndIndex = cleanedJsonString.lastIndexOf('}');

    if (jsonStartIndex === -1 || jsonEndIndex === -1 || jsonEndIndex < jsonStartIndex) {
        throw new Error("AI response did not contain a recognizable JSON object.");
    }
    cleanedJsonString = cleanedJsonString.substring(jsonStartIndex, jsonEndIndex + 1);

    let parsedData: unknown;
    try {
        parsedData = JSON.parse(cleanedJsonString);
    } catch (parseError: unknown) {
        throw new Error(`Failed to parse AI suggestions. Invalid JSON format. ${parseError instanceof Error ? `Details: ${parseError.message}` : ''}`);
    }

    if (typeof parsedData !== 'object' || parsedData === null) {
        throw new Error("Validation Error: AI response is not a JSON object.");
    }

    const potentialContent = parsedData as Record<string, unknown>;
    const validatedOutput: PersonalizedMealContent = { meals: [] };

    // --- Validate Meals ---
    if (!potentialContent.hasOwnProperty('meals') || !Array.isArray(potentialContent.meals)) {
        throw new Error("Validation Error: AI response missing required 'meals' array.");
    }

    // Process meals
    validatedOutput.meals = potentialContent.meals
        .map((item: unknown, index: number): MealIdea | null => {
            if (typeof item !== 'object' || item === null) { return null; }
            const meal = item as Record<string, unknown>;

            // Required fields check
            if (typeof meal.id !== 'string' || !meal.id.trim()) { return null; } // Added ID check
            if (typeof meal.name !== 'string' || !meal.name.trim()) { return null; }
            if (typeof meal.description !== 'string' || !meal.description.trim()) { return null; }
            if (typeof meal.mealType !== 'string' || !meal.mealType.trim()) { return null; }
            if (!Array.isArray(meal.preparationSteps)) { return null; }

            // Optional & New Fields Validation & Cleaning
            const keyIngredients = Array.isArray(meal.keyIngredients) ? meal.keyIngredients.filter((k): k is string => typeof k === 'string' && !!k.trim()).map(k => k.trim()) : [];
            const dietaryNotes = Array.isArray(meal.dietaryNotes) ? meal.dietaryNotes.filter((n): n is string => typeof n === 'string' && !!n.trim()).map(n => n.trim()) : [];
            const prepTime = (typeof meal.prepTime === 'string' && meal.prepTime.trim()) ? meal.prepTime.trim() : undefined;
            const cookingTime = (typeof meal.cookingTime === 'string' && meal.cookingTime.trim()) ? meal.cookingTime.trim() : undefined;
            const servingSize = (typeof meal.servingSize === 'string' && meal.servingSize.trim()) ? meal.servingSize.trim() : undefined;
            const macros = (typeof meal.macros === 'string' && meal.macros.trim()) ? meal.macros.trim() : undefined;
            // Ensure preparationSteps contains only non-empty strings
            const preparationSteps = meal.preparationSteps.filter((s): s is string => typeof s === 'string' && !!s.trim()).map(s => s.trim());
            const reasoning = (typeof meal.reasoning === 'string' && meal.reasoning.trim()) ? meal.reasoning.trim() : undefined;

            let recipeComplexityValue: string | undefined = (typeof meal.recipeComplexity === 'string' && meal.recipeComplexity.trim()) ? meal.recipeComplexity.trim() : undefined;
            const finalComplexity = (recipeComplexityValue && VALID_RECIPE_COMPLEXITY.includes(recipeComplexityValue as RecipeComplexity)) ? recipeComplexityValue : "Easy"; // Default to Easy
            const finalMealType = VALID_MEAL_TYPES.includes(meal.mealType as MealType) ? meal.mealType : "Snack"; // Default to Snack

            // Re-assign a client-side ID for robustness if needed, or trust AI's ID if validated
            const finalId = meal.id.trim(); // Use the validated ID from AI

            return {
                id: finalId,
                name: meal.name.trim(),
                description: meal.description.trim(),
                mealType: finalMealType,
                keyIngredients, dietaryNotes, prepTime, cookingTime, recipeComplexity: finalComplexity,
                servingSize, macros, preparationSteps, reasoning,
            };
        })
        .filter((item): item is MealIdea => item !== null);

    if (validatedOutput.meals.length === 0 && potentialContent.meals.length > 0) {
       // No valid items found, though the array existed. This might indicate format issues.
       // Consider logging or throwing an error depending on strictness required.
       console.warn("Validation Warning: AI 'meals' array contained items, but none passed validation.");
    }

    return validatedOutput;
};


// --- Public API Function ---

/**
 * Fetches personalized meal suggestions from Groq.
 * Handles API communication, response processing, and validation.
 *
 * @async
 * @param {UserProfile} profile - The user's profile data.
 * @param {MealGenerationOptions} [options={}] - Options to customize the meal request.
 * @returns {Promise<PersonalizedMealContent>} A Promise resolving to validated meal suggestions.
 * @throws {Error} If service unavailable, API call fails, or validation fails critically.
 */
export const generatePersonalizedMeals = async (
    profile: UserProfile,
    options: MealGenerationOptions = {}
): Promise<PersonalizedMealContent> => {
    if (!groq) {
        throw new Error("Meal suggestion service unavailable (Groq client not initialized). Check API Key.");
    }

    const prompt = createMealPersonalizationPrompt(profile, options);
    const messages: ChatCompletionMessageParam[] = [{ role: 'user', content: prompt }];
    const params: ChatCompletionCreateParams = {
        messages, model: MODEL_NAME, temperature: generationConfig.temperature,
        max_tokens: generationConfig.max_tokens, top_p: generationConfig.top_p, stream: false,
        // Ensure JSON mode if the model supports it, otherwise rely on prompt instructions
        // response_format: { type: "json_object" }, // Uncomment if using a model version that explicitly supports this
    };

    try {
        const chatCompletion: ChatCompletion = await groq.chat.completions.create(params);

        const choice = chatCompletion.choices?.[0];
        const responseText = choice?.message?.content;
        const finishReason = choice?.finish_reason;

        if (finishReason !== 'stop' && finishReason !== 'length') {
            if (typeof finishReason === 'string' && finishReason.toLowerCase().includes('filter')) {
                throw new Error(`AI generation blocked for safety/content reasons (${finishReason}).`);
            }
            throw new Error(`AI generation stopped unexpectedly (Reason: ${finishReason || 'unknown'}).`);
        }

        if (!responseText && finishReason !== 'stop') {
             if (finishReason === 'length') { console.warn("AI response content empty/null, reason 'length'. Attempting parse (may fail)."); }
             else { throw new Error(`AI returned unexpected empty content (Reason: ${finishReason}).`); }
        }

        if (responseText === "" && finishReason === 'stop') {
             console.warn("AI returned empty string response. Returning empty suggestions.");
             return { meals: [] };
        }

        if (finishReason === 'length') { console.warn("AI response may be truncated. JSON/Suggestions might be incomplete."); }

        if (responseText === null || responseText === undefined) {
             throw new Error("AI response content was unexpectedly null or undefined.");
        }

        return parseAndValidateMealContent(responseText);

    } catch (error: unknown) {
        console.error(`Error during Groq meal personalization fetch/parse:`, error);
        if (error instanceof Groq.APIError) {
            const status = error.status ?? 'N/A';
            const message = error.message || 'Unknown API error.';
            throw new Error(`Meal personalization service API error (Status: ${status}): ${message}`);
        } else if (error instanceof Error) {
            // Re-throw validation errors or other specific errors
            throw error;
        } else {
            throw new Error("An unexpected error occurred while fetching personalized meal content.");
        }
    }
};

// --- Service Object Export ---
export const groqMealService = {
    generatePersonalizedMeals,
};