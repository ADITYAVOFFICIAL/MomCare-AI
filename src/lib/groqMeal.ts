// src/lib/groqMeal.ts

import Groq from 'groq-sdk';

// --- SDK Type Imports ---
// Assuming these types are correctly imported from the groq-sdk package
import {
    ChatCompletionCreateParamsNonStreaming,
    ChatCompletionCreateParamsStreaming,
    ChatCompletionCreateParamsBase,
    ChatCompletionMessageParam,
    ChatCompletion
} from 'groq-sdk/resources/chat/completions';

// --- Appwrite Type Imports ---
import { UserProfile } from './appwrite'; // Adjust path if necessary

// --- Constants for Type Validation ---

/** Valid meal types allowed in the MealIdea interface. */
export const VALID_MEAL_TYPES = ["Breakfast", "Lunch", "Dinner", "Snack", "Dessert"] as const;
/** Union type representing allowed meal types. */
export type MealType = typeof VALID_MEAL_TYPES[number];

/** Valid exercise intensity levels. */
export const VALID_EXERCISE_INTENSITIES = ["Gentle", "Light", "Moderate"] as const;
/** Union type representing allowed exercise intensities. */
export type ExerciseIntensity = typeof VALID_EXERCISE_INTENSITIES[number];

/** Valid recipe complexity levels. */
export const VALID_RECIPE_COMPLEXITY = ["Easy", "Medium", "Hard"] as const;
/** Union type representing allowed recipe complexities. */
export type RecipeComplexity = typeof VALID_RECIPE_COMPLEXITY[number];

// --- Interface Definitions ---

/**
 * Represents a single meal idea generated by the AI.
 * Includes more detail for popup view.
 */
export interface MealIdea {
  /** Unique identifier (can be generated client-side or by AI if prompted) */
  id: string;
  /** Name of the meal */
  name: string;
  /** Short description, key ingredients, nutritional highlight (Markdown possible) */
  description: string;
  /** Type of meal (e.g., "Breakfast", "Snack") */
  mealType: MealType | string; // Allows string fallback if AI deviates
  /** Array of main ingredients (e.g., ["Chicken Breast", "Broccoli", "Quinoa"]) */
  keyIngredients?: string[];
  /** Applicable dietary flags (e.g., ["Gluten-Free", "Vegetarian"]) */
  dietaryNotes?: string[];
  /** Estimated preparation time (e.g., "Approx. 15 mins") */
  prepTime?: string;
  /** Estimated cooking time (e.g., "Approx. 30 mins") (NEW) */
  cookingTime?: string;
  /** Difficulty level (e.g., "Easy") */
  recipeComplexity?: RecipeComplexity | string; // Allows string fallback
  /** Estimated serving size (e.g., "Serves 2") (NEW) */
  servingSize?: string;
  /** Estimated macros as a string, e.g., "P: 30g, C: 45g, F: 15g" (NEW) */
  macros?: string;
  /** Array of step-by-step instructions (NEW) */
  preparationSteps?: string[];
  /** AI's explanation for why this suggestion is relevant */
  reasoning?: string;
}

/**
 * Represents a single exercise suggestion generated by the AI.
 * (Interface remains the same as previous version)
 */
export interface ExerciseSuggestion {
  /** Unique identifier */
  id: string;
  /** Name of the exercise */
  name: string;
  /** How to perform it or its benefits (Markdown possible) */
  description: string;
  /** Intensity level (e.g., "Gentle", "Light") */
  intensity: ExerciseIntensity | string; // Allows string fallback
  /** Suggested duration or repetitions (e.g., "10-15 minutes", "3 sets of 10 reps") */
  durationReps?: string;
  /** Primary benefit area (e.g., "Back Pain Relief", "Pelvic Floor", "Circulation") */
  focusArea?: string;
  /** **Crucial** safety precautions or contraindications */
  safetyNotes: string;
  /** AI's explanation for why this suggestion is relevant */
  reasoning?: string;
}

/** Structure for the AI's response */
export interface PersonalizedContent {
  /** Array of generated meal ideas */
  meals: MealIdea[];
  /** Array of generated exercise suggestions */
  exercises: ExerciseSuggestion[];
}

/** Options to customize the content generation request */
export interface GenerationOptions {
  /** Specifies whether to generate 'meals', 'exercises', or 'both'. Defaults to 'both'. */
  contentType?: 'meals' | 'exercises' | 'both';
  /** Approximate number of suggestions desired for each requested type. Defaults to 3. */
  count?: number;
  /** A specific user request, craving, or area of focus to guide the AI. */
  customPreference?: string;
}

// --- Internal Types ---
/** Local union type for Groq Chat Completion Create parameters */
type ChatCompletionCreateParams = ChatCompletionCreateParamsNonStreaming | ChatCompletionCreateParamsStreaming;

// --- Configuration ---
/** Groq API Key loaded from environment variables. */
const API_KEY: string | undefined = import.meta.env.VITE_PUBLIC_GROQ_API_KEY;
/** Specifies the Groq AI model to use for generation. */
const MODEL_NAME: ChatCompletionCreateParamsBase['model'] = "llama3-70b-8192";

// Validate API Key presence
if (!API_KEY) {
    // console.error("CRITICAL ERROR: VITE_PUBLIC_GROQ_API_KEY is missing. Meal/Exercise generation will be unavailable.");
    // NOTE: In a production environment, you might throw an Error here
    // to prevent the application module from loading incorrectly.
    // throw new Error("Groq API Key is missing. Cannot initialize groqMealService.");
}

/** Initialized Groq SDK client instance, or null if API key is missing. */
const groq: Groq | null = API_KEY ? new Groq({ apiKey: API_KEY, dangerouslyAllowBrowser: true }) : null;

/** Configuration settings for the AI generation process. */
const generationConfig = {
    temperature: 0.7,
    max_tokens: 4096, // Sufficient for detailed JSON output
    top_p: 0.9,
};

// --- Helper Functions ---

/**
 * Helper to get basic trimester info based on weeks pregnant.
 * @param weeks - Weeks pregnant (number or string). Can be undefined/null/NaN.
 * @returns A descriptive string about the trimester or status.
 */
const getTrimesterInfo = (weeks: number | string | undefined | null): string => {
    const numWeeks = parseInt(String(weeks), 10); // Attempt to parse whatever is given
    if (isNaN(numWeeks) || numWeeks < 1) return "Pregnancy stage unknown"; // Handle invalid or zero weeks
    if (numWeeks <= 13) return "First trimester";
    if (numWeeks <= 27) return "Second trimester";
    if (numWeeks <= 42) return "Third trimester"; // Allow slightly beyond 40
    return "Post-term or invalid weeks"; // Handle cases beyond typical range
};

/**
 * Creates the detailed prompt for the Groq API based on user profile and options.
 * Includes context, safety guidelines, role definition, and strict JSON output format instructions.
 *
 * @param profile - The user's profile data from Appwrite.
 * @param options - Options to customize the request (content type, count, custom preference).
 * @returns The formatted prompt string ready for the API call.
 */
const createPersonalizationPrompt = (profile: UserProfile, options: GenerationOptions = {}): string => {
    // Destructure options with defaults
    const { contentType = 'both', count = 3, customPreference } = options;

    // Safely extract profile data with fallbacks
    const weeks = profile.weeksPregnant ?? 'unknown';
    const activity = profile.activityLevel ?? 'unspecified';
    const conditions = profile.preExistingConditions?.trim() || 'none specified';
    const diet = profile.dietaryPreferences?.length ? profile.dietaryPreferences.join(', ') : 'none specified';

    // Build context string
    let context = `**User Context:**\n`;
    context += `- Pregnancy Stage: ${weeks} weeks (Implications: ${getTrimesterInfo(weeks)})\n`;
    context += `- Stated Activity Level: ${activity}\n`;
    context += `- Stated Dietary Preferences: ${diet}\n`;
    if (conditions !== 'none specified') {
        context += `- Stated Pre-existing Conditions: ${conditions} (Acknowledge for context only, DO NOT give medical advice related to these)\n`;
    }
    if (customPreference?.trim()) {
        context += `- User's Current Request/Focus: "${customPreference.trim()}"\n`;
    }
    // Add guidance for minimal context
    if (weeks === 'unknown' && activity === 'unspecified' && diet === 'none specified' && conditions === 'none specified') {
        context += `- Note: User profile context is minimal. Provide generally safe and helpful pregnancy suggestions.\n`;
    }


    // Define safety instructions and AI role
    const safetyInstructions = `
**Safety & Role Definition:**
- You are MomCare AI, an informational assistant providing general suggestions. You are **NOT** a medical professional, doctor, registered dietitian, or certified personal trainer. Your advice is not a substitute for professional consultation.
- **ALL suggestions (meals and exercises) are purely informational and MUST NOT be taken as medical or professional advice.**
- **CRITICAL (Exercise Safety):** For **every** exercise suggestion, the "safetyNotes" field **MUST** clearly state: "Consult your doctor or midwife before starting any new exercise during pregnancy. Listen to your body and stop immediately if you feel pain or discomfort." Add any specific precautions for the exercise itself (e.g., "Avoid lying flat on your back in later trimesters").
- **CRITICAL (Meal Safety):** For meal suggestions, the "description" or "reasoning" **MUST** mention that it's a general idea and individual dietary needs vary significantly during pregnancy. Advise the user to consult their healthcare provider or a registered dietitian for personalized dietary plans. Macros provided are **estimates only**. Preparation steps are **suggestions**.
- Base suggestions on general, evidence-based knowledge about pregnancy nutritional needs (e.g., importance of folate, iron, calcium, protein) and universally recommended safe exercise principles (e.g., focus on low-impact activities, avoiding falls risk, adapting to trimester changes).
- **DO NOT** suggest specific supplement dosages or brands. Always refer the user to their healthcare provider for supplement advice.
- **DO NOT** attempt to diagnose, treat, or manage any medical conditions mentioned in the profile. Acknowledge conditions only to tailor general suggestions appropriately (e.g., suggest lower-impact exercise if joint pain is mentioned, suggest recipes aligning with stated dietary needs like 'vegetarian').
`;

    // Define strict JSON output format (including new meal fields)
    const outputFormatInstructions = `
**Output Format Instructions:**
Provide the response STRICTLY as a valid JSON object. NO extra text, greetings, or explanations outside the JSON structure.
The top-level object structure depends on the requested 'contentType':
- If 'contentType' is 'meals', the JSON object MUST ONLY have a "meals" key (array of meal objects).
- If 'contentType' is 'exercises', the JSON object MUST ONLY have an "exercises" key (array of exercise objects).
- If 'contentType' is 'both' (default), the JSON object MUST have BOTH keys: "meals" and "exercises", each containing their respective arrays.

Generate approximately ${count} valid suggestions for each requested type. Ensure all suggestions are relevant to the provided user context and custom request (if any).

**Meal Idea Object Structure (within "meals" array):**
- "name": (string) Catchy and descriptive name.
- "description": (string) 1-3 sentences for card view (benefits, features). Use Markdown. Mention need for professional dietary advice.
- "mealType": (string) Must be one of: ${VALID_MEAL_TYPES.join(', ')}.
- "keyIngredients": (array of strings) List 3-5 main ingredients.
- "dietaryNotes": (array of strings, optional) e.g., ["Vegetarian"]. Empty array [] if none apply.
- "prepTime": (string, optional) e.g., "Approx. 15 mins".
- "cookingTime": (string, optional) e.g., "Approx. 30 mins".
- "recipeComplexity": (string) Must be one of: ${VALID_RECIPE_COMPLEXITY.join(', ')}.
- "servingSize": (string, optional) e.g., "Serves 2-3".
- "macros": (string, optional) Estimated macros, e.g., "Approx. P: 30g, C: 50g, F: 18g per serving". **Must state these are estimates.**
- "preparationSteps": (array of strings) Clear, step-by-step instructions. **Must be an array of strings.**
- "reasoning": (string, optional) Max 20 words on relevance.

**Exercise Suggestion Object Structure (within "exercises" array):**
- "name": (string) Clear name.
- "description": (string) 1-3 sentences how-to/benefit. Use Markdown.
- "intensity": (string) One of: ${VALID_EXERCISE_INTENSITIES.join(', ')}.
- "durationReps": (string, optional) e.g., "15-20 minutes", "3 sets of 12 reps".
- "focusArea": (string, optional) e.g., "Pelvic Floor".
- "safetyNotes": (string) **MANDATORY.** Specific precautions + **explicit reminder to consult provider**.
- "reasoning": (string, optional) Max 20 words on relevance.

**Example Meal Object with New Fields:**
{
  "name": "Quinoa Salad with Chickpeas & Roasted Veggies",
  "description": "A vibrant, nutrient-dense salad providing complete protein from quinoa and chickpeas, plus plenty of vitamins from roasted vegetables. *Remember, dietary needs vary during pregnancy; consult your healthcare provider or dietitian for personalized advice.*",
  "mealType": "Lunch",
  "keyIngredients": ["Quinoa", "Chickpeas", "Bell Peppers", "Zucchini", "Lemon-tahini dressing"],
  "dietaryNotes": ["Vegetarian", "Gluten-Free"],
  "prepTime": "Approx. 20 mins",
  "cookingTime": "Approx. 25 mins (for roasting)",
  "recipeComplexity": "Easy",
  "servingSize": "Serves 2",
  "macros": "Estimated per serving: P: 18g, C: 60g, F: 15g (Values are approximate)",
  "preparationSteps": [
    "Preheat oven to 400°F (200°C). Chop bell peppers and zucchini.",
    "Toss vegetables with olive oil, salt, and pepper. Roast for 20-25 minutes until tender.",
    "Cook quinoa according to package directions.",
    "Rinse and drain chickpeas.",
    "Whisk together lemon juice, tahini, olive oil, garlic (optional), salt, and pepper for the dressing.",
    "Combine cooked quinoa, roasted vegetables, and chickpeas in a large bowl.",
    "Drizzle with dressing and toss gently to combine. Serve warm or cold."
  ],
  "reasoning": "Balanced plant-based protein, fiber, and vitamins."
}

**CRITICAL Rules:**
- **Output ONLY the JSON object string.** No introductory text, concluding remarks, or markdown formatting outside the JSON string values.
- Adhere STRICTLY to the requested 'contentType' and the defined object structures, including data types (string, array of strings).
- Ensure valid JSON syntax: double quotes for all keys and string values, correct comma placement, valid arrays.
- Ensure all mandatory fields (like 'safetyNotes' for exercises) are present and non-empty. 'preparationSteps' for meals must be an array of strings, even if empty [].
`;

    // Determine the main instruction based on contentType
    let mainInstruction = "";
    if (contentType === 'meals') {
        mainInstruction = `Generate personalized meal ideas based *specifically* on the user's context. Ensure all fields in the Meal Idea Object Structure are included.`;
    } else if (contentType === 'exercises') {
        mainInstruction = `Generate personalized, pregnancy-safe exercise suggestions based *specifically* on the user's context. Ensure all fields in the Exercise Suggestion Object Structure are included.`;
    } else { // 'both'
        mainInstruction = `Generate personalized meal ideas AND pregnancy-safe exercise suggestions based *specifically* on the user's context. Ensure all fields in both Object Structures are included.`;
    }

    // Assemble the final prompt
    return `
You are MomCare AI, an informational assistant for pregnant users. Provide supportive, safe, general suggestions based on the user's profile while strictly adhering to safety guidelines and JSON output format.

${context}
${safetyInstructions}
${mainInstruction} Adhere precisely to the output format instructions below.
${outputFormatInstructions}
`;
};


/**
 * Parses and validates the AI's JSON response, now including new meal fields.
 * Filters out invalid items within the arrays but preserves valid ones.
 *
 * @param responseText - Raw API response text.
 * @param requestedContentType - Type of content requested.
 * @returns Validated PersonalizedContent object.
 * @throws Error if JSON is invalid or missing required top-level keys.
 */
const parseAndValidateContent = (responseText: string, requestedContentType: GenerationOptions['contentType'] = 'both'): PersonalizedContent => {
    let cleanedJsonString = responseText.trim();
    const jsonStartIndex = cleanedJsonString.indexOf('{');
    const jsonEndIndex = cleanedJsonString.lastIndexOf('}');

    if (jsonStartIndex === -1 || jsonEndIndex === -1 || jsonEndIndex < jsonStartIndex) {
        // console.error("Validation Error: Response missing JSON object structure:", responseText);
        throw new Error("AI response did not contain a recognizable JSON object.");
    }
    cleanedJsonString = cleanedJsonString.substring(jsonStartIndex, jsonEndIndex + 1);

    let parsedData: unknown;
    try {
        parsedData = JSON.parse(cleanedJsonString);
    } catch (parseError: unknown) {
        // console.error("Validation Error: Failed to parse AI JSON:", parseError);
        // console.error("Cleaned JSON string:", cleanedJsonString);
        throw new Error(`Failed to parse AI suggestions. Invalid JSON format. ${parseError instanceof Error ? `Details: ${parseError.message}` : ''}`);
    }

    if (typeof parsedData !== 'object' || parsedData === null) {
        throw new Error("Validation Error: AI response is not a JSON object.");
    }

    const potentialContent = parsedData as Record<string, unknown>;
    const validatedOutput: PersonalizedContent = { meals: [], exercises: [] };

    // --- Validate Meals ---
    if (requestedContentType === 'meals' || requestedContentType === 'both') {
        if (!potentialContent.hasOwnProperty('meals') || !Array.isArray(potentialContent.meals)) {
            // If only meals were requested, this is a critical error
            if (requestedContentType === 'meals') {
                throw new Error("Validation Error: AI response missing required 'meals' array when only meals were requested.");
            } else {
                //  console.warn("Validation Warning: AI response missing 'meals' array when 'both' were requested. Proceeding without meals.");
                 // Allow proceeding if 'both' was requested, maybe exercises are valid
            }
        } else {
            // Process meals if the array exists
            validatedOutput.meals = potentialContent.meals
                .map((item: unknown, index: number): MealIdea | null => {
                    if (typeof item !== 'object' || item === null) { /*console.warn(`Validation Warning: Meal item ${index} is not an object.`);*/ return null; }
                    const meal = item as Record<string, unknown>;

                    // Required fields check
                    if (typeof meal.name !== 'string' || !meal.name.trim()) { /*console.warn(`Validation Warning: Meal item ${index} invalid 'name'.`);*/ return null; }
                    if (typeof meal.description !== 'string' || !meal.description.trim()) { /*console.warn(`Validation Warning: Meal item ${index} invalid 'description'.`);*/ return null; }
                    if (typeof meal.mealType !== 'string' || !meal.mealType.trim()) { /*console.warn(`Validation Warning: Meal item ${index} invalid 'mealType'.`);*/ return null; }
                    // Preparation steps are now expected
                    if (!Array.isArray(meal.preparationSteps)) { /*console.warn(`Validation Warning: Meal item ${index} ('${meal.name}') missing or invalid 'preparationSteps' (must be an array).`);*/ return null; }

                    // Optional & New Fields Validation & Cleaning
                    const keyIngredients = Array.isArray(meal.keyIngredients) ? meal.keyIngredients.filter((k): k is string => typeof k === 'string' && !!k.trim()).map(k => k.trim()) : [];
                    const dietaryNotes = Array.isArray(meal.dietaryNotes) ? meal.dietaryNotes.filter((n): n is string => typeof n === 'string' && !!n.trim()).map(n => n.trim()) : [];
                    const prepTime = (typeof meal.prepTime === 'string' && meal.prepTime.trim()) ? meal.prepTime.trim() : undefined;
                    const cookingTime = (typeof meal.cookingTime === 'string' && meal.cookingTime.trim()) ? meal.cookingTime.trim() : undefined;
                    const servingSize = (typeof meal.servingSize === 'string' && meal.servingSize.trim()) ? meal.servingSize.trim() : undefined;
                    const macros = (typeof meal.macros === 'string' && meal.macros.trim()) ? meal.macros.trim() : undefined;
                    // Ensure preparationSteps contains only non-empty strings
                    const preparationSteps = meal.preparationSteps.filter((s): s is string => typeof s === 'string' && !!s.trim()).map(s => s.trim());
                    const reasoning = (typeof meal.reasoning === 'string' && meal.reasoning.trim()) ? meal.reasoning.trim() : undefined;

                    let recipeComplexityValue: string | undefined = (typeof meal.recipeComplexity === 'string' && meal.recipeComplexity.trim()) ? meal.recipeComplexity.trim() : undefined;
                    const finalComplexity = (recipeComplexityValue && VALID_RECIPE_COMPLEXITY.includes(recipeComplexityValue as RecipeComplexity)) ? recipeComplexityValue : "Easy";
                    const finalMealType = VALID_MEAL_TYPES.includes(meal.mealType as MealType) ? meal.mealType : "Snack";

                    return {
                        id: `meal-${Date.now()}-${index}`,
                        name: meal.name.trim(),
                        description: meal.description.trim(),
                        mealType: finalMealType,
                        keyIngredients, dietaryNotes, prepTime, cookingTime, recipeComplexity: finalComplexity,
                        servingSize, macros, preparationSteps, reasoning,
                    };
                })
                .filter((item): item is MealIdea => item !== null);

            if (validatedOutput.meals.length < potentialContent.meals.length) {
                // console.warn(`Validation Warning: Filtered out ${potentialContent.meals.length - validatedOutput.meals.length} invalid meal items.`);
            }
            if (validatedOutput.meals.length === 0 && potentialContent.meals.length > 0) {
                // console.error("Validation Error: AI 'meals' array contained no valid items after validation.");
            }
        }
    } else if (potentialContent.hasOwnProperty('meals')) {
        //  console.warn("Validation Warning: AI included 'meals' key when not requested.");
    }


    // --- Validate Exercises ---
     if (requestedContentType === 'exercises' || requestedContentType === 'both') {
        if (!potentialContent.hasOwnProperty('exercises')) {
             if (requestedContentType === 'exercises') {
                throw new Error("Validation Error: AI response missing required 'exercises' array when only exercises were requested.");
             } else {
                //  console.warn("Validation Warning: AI response missing 'exercises' array when 'both' were requested. Proceeding without exercises.");
             }
        } else if (!Array.isArray(potentialContent.exercises)) {
             throw new Error(`Validation Error: AI response 'exercises' field is not an array (Type: ${typeof potentialContent.exercises}).`);
        } else {
            // Process exercises if the array exists and is valid
            validatedOutput.exercises = potentialContent.exercises
                .map((item: unknown, index: number): ExerciseSuggestion | null => {
                    if (typeof item !== 'object' || item === null) { /*console.warn(`Validation Warning: Exercise item ${index} not an object.`);*/ return null; }
                    const ex = item as Record<string, unknown>;
                    if (typeof ex.name !== 'string' || !ex.name.trim()) { /*console.warn(`Validation Warning: Ex item ${index} invalid 'name'.`);*/ return null; }
                    if (typeof ex.description !== 'string' || !ex.description.trim()) { /*console.warn(`Validation Warning: Ex item ${index} invalid 'description'.`);*/ return null; }
                    if (typeof ex.intensity !== 'string' || !ex.intensity.trim()) { /*console.warn(`Validation Warning: Ex item ${index} invalid 'intensity'.`);*/ return null; }
                    if (typeof ex.safetyNotes !== 'string' || !ex.safetyNotes.trim()) { /*console.warn(`Validation Warning: Ex item ${index} invalid 'safetyNotes'.`);*/ return null; }

                    const durationReps = (typeof ex.durationReps === 'string' && ex.durationReps.trim()) ? ex.durationReps.trim() : undefined;
                    const focusArea = (typeof ex.focusArea === 'string' && ex.focusArea.trim()) ? ex.focusArea.trim() : undefined;
                    const reasoning = (typeof ex.reasoning === 'string' && ex.reasoning.trim()) ? ex.reasoning.trim() : undefined;
                    const finalIntensity = VALID_EXERCISE_INTENSITIES.includes(ex.intensity as ExerciseIntensity) ? ex.intensity : "Gentle";

                    return {
                        id: `ex-${Date.now()}-${index}`, name: ex.name.trim(), description: ex.description.trim(),
                        intensity: finalIntensity, durationReps, focusArea, safetyNotes: ex.safetyNotes.trim(), reasoning,
                    };
                })
                .filter((item): item is ExerciseSuggestion => item !== null);

            if (validatedOutput.exercises.length < potentialContent.exercises.length) {
                // console.warn(`Validation Warning: Filtered out ${potentialContent.exercises.length - validatedOutput.exercises.length} invalid exercise items.`);
            }
            if (validatedOutput.exercises.length === 0 && potentialContent.exercises.length > 0) {
                // console.error("Validation Error: AI 'exercises' array contained no valid items after validation.");
            }
        }
    } else if (potentialContent.hasOwnProperty('exercises')) {
        //  console.warn("Validation Warning: AI included 'exercises' key when not requested.");
    }

    // console.log(`Validation Complete: Found ${validatedOutput.meals.length} valid meals, ${validatedOutput.exercises.length} valid exercises.`);
    return validatedOutput;
};


// --- Public API Function ---

/**
 * Fetches personalized meal and/or exercise suggestions from Groq.
 * Handles API communication, response processing, and validation including new meal details.
 *
 * @async
 * @param {UserProfile} profile - The user's profile data.
 * @param {GenerationOptions} [options={}] - Options to customize the request.
 * @returns {Promise<PersonalizedContent>} A Promise resolving to validated suggestions.
 * @throws {Error} If service unavailable, API call fails, or validation fails critically.
 */
export const generatePersonalizedContent = async (
    profile: UserProfile,
    options: GenerationOptions = {}
): Promise<PersonalizedContent> => {
    if (!groq) {
        throw new Error("Meal/Exercise suggestion service unavailable (Groq client not initialized). Check API Key.");
    }

    const { contentType = 'both' } = options;
    const prompt = createPersonalizationPrompt(profile, options);
    const messages: ChatCompletionMessageParam[] = [{ role: 'user', content: prompt }];
    const params: ChatCompletionCreateParams = {
        messages, model: MODEL_NAME, temperature: generationConfig.temperature,
        max_tokens: generationConfig.max_tokens, top_p: generationConfig.top_p, stream: false,
    };

    try {
        // console.log(`Sending personalization request to Groq (requesting: ${contentType})...`);
        const chatCompletion: ChatCompletion = await groq.chat.completions.create(params);
        // console.log("Received personalization response from Groq.");

        const choice = chatCompletion.choices?.[0];
        const responseText = choice?.message?.content;
        const finishReason = choice?.finish_reason;
        // console.log(`Groq generation finished. Reason: ${finishReason || 'N/A'}.`);

        if (finishReason !== 'stop' && finishReason !== 'length') {
            if (typeof finishReason === 'string' && finishReason.toLowerCase().includes('filter')) {
                throw new Error(`AI generation blocked for safety/content reasons (${finishReason}).`);
            }
            throw new Error(`AI generation stopped unexpectedly (Reason: ${finishReason || 'unknown'}).`);
        }
        if (!responseText && finishReason !== 'stop') {
            if (finishReason === 'length') { /*console.warn("AI response content empty/null, reason 'length'. Attempting parse (may fail).");*/ }
            else { throw new Error(`AI returned unexpected empty content (Reason: ${finishReason}).`); }
        }
        if (responseText === "" && finishReason === 'stop') {
            //  console.warn("AI returned empty string response. Returning empty suggestions.");
             return { meals: [], exercises: [] };
        }
        if (finishReason === 'length') { /*console.warn("AI response may be truncated. JSON/Suggestions might be incomplete.");*/ }
        if (responseText === null || responseText === undefined) {
            //  console.error("Response text null/undefined despite finish reason. Cannot parse.");
             throw new Error("AI response content was unexpectedly null or undefined.");
        }

        return parseAndValidateContent(responseText, contentType);

    } catch (error: unknown) {
        // console.error(`Error during Groq personalization fetch/parse (Type: ${contentType}):`, error);
        if (error instanceof Groq.APIError) {
            const status = error.status ?? 'N/A';
            const message = error.message || 'Unknown API error.';
            throw new Error(`Personalization service API error (Status: ${status}): ${message}`);
        } else if (error instanceof Error) {
            throw error;
        } else {
            throw new Error("An unexpected error occurred while fetching personalized content.");
        }
    }
};

// --- Service Object Export ---
export const groqMealService = {
    generatePersonalizedContent,
};